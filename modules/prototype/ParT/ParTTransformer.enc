module ParTTransformer (
    arrT,
    firstT,
    composeT)

import ParT.ParT
import ParT.Arrow as A

typedef Transformer[a, b] = PArrow[a, Par[(Par[b], Par [a -> Par[b]])]]

fun arrT[a, b](fn: PArrow[a, Par[b]]): Transformer[a, b]
  val transformer = fun (x: a) => join(runArrow(x, fn))
  -- issue: `A.arr` is synonym for `liftv` but it does not typecheck
  A.arr(fun (y: a) => liftv((transformer(y), A.arr(transformer))))
end

fun firstT[a, b, c](fn: PArrow[a, Par[b]]): Transformer[(a, c), (b, c)]
  val transformer = fun (t: (a, c)) => join(runArrow(t.0, fn)) >> fun (x: b) => (x, t.1)
  A.arr(fun (t: (a, c)) => liftv((transformer(t), A.arr(transformer))))
end

-- a b c -> (b, a b c)
-- Transformer[a, b] = PArrow[a, Par[(Par[b], Par [a -> Par[b]])]]
-- Transformer[b, c] = PArrow[b, Par[(Par[c], Par [b -> Par[c]])]]
-- Transformer[a, c] = PArrow[a, Par[(Par[c], Par [a -> Par[c]])]]
fun composeT[a, b, c](t1: Transformer[a, b], t2: Transformer[b, c]): Transformer[a, c]
  val transformer = fun (x: a)
                      val pTuple = join(runArrow(x, t1)) -- Par[(Par[b], Par [a -> Par[b]])]
                      val clos = fun (tuple: (Par[b], PArrow[a, Par[b]]))
                                   val pb = tuple.0
                                   val inter = join(runParArrow(pb, t2)) -- Par[(Par[c], Par [b -> Par[c]])]
                                   inter >> (fun (tInterm: (Par[c], Par[b -> Par[c]]))
                                              (tInterm.0, A.composePar(tuple.1, tInterm.1))
                                             end)
                                 end
                      bind(clos, pTuple) -- (a -> Par[b]) ->  Par[a] -> Par[b]
                    end
  liftv(transformer)
end

fun runTrans[a, b](item: a, t: Transformer[a, b]): Par[(Par[b], Transformer[a, b])]
  val pp = join(runArrow(item, t))  -- Par[(Par[b], Par[a -> Par[b]])]
  pp >> (fun (p: (Par[b], Par[a -> Par[b]]))
          (p.0, arrT(p.1))
         end)
end

fun inc(x: int): Par[int]
  println("Printing Inc: {}", x + 1)
  liftv(x + 1)
end

fun double(x: int): Par[int]
  println("Printing Double: {}", x * x)
  liftv(x * x)
end

class Main
  def main(): unit
    val arrowInc = A.arr(inc)
    val arrowDouble = A.arr(double)
    val transformerInc = arrT(arrowInc)
    val transformerDouble = arrT(arrowDouble)
    val transformer = composeT(transformerInc, transformerDouble)
    val p = runTrans(3, transformer)
    p >> (fun (t: (Par[int], Transformer[int, int]))
            (t.0) >> fun (x: int) => runTrans(x, t.1)
          end)
  end
end

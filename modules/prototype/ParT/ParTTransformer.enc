module ParTTransformer (
    arrT,
    firstT,
    composeT)

import ParT.ParT
import ParT.Arrow as A

typedef Transformer[a, b] = PArrow[a, Par[(Par[b], Par [a -> Par[b]])]]

fun arrT[a, b](fn: PArrow[a, Par[b]]): Transformer[a, b]
  val transformer = fun (x: a) => join(runArrow(x, fn))
  -- issue: `A.arr` is synonym for `liftv` but it does not typecheck
  A.arr(fun (y: a) => liftv((transformer(y), A.arr(transformer))))
end

fun firstT[a, b, c](fn: PArrow[a, Par[b]]): Transformer[(a, c), (b, c)]
  val transformer = fun (t: (a, c)) => join(runArrow(t.0, fn)) >> fun (x: b) => (x, t.1)
  A.arr(fun (t: (a, c)) => liftv((transformer(t), A.arr(transformer))))
end

-- Transformer[a, b] = PArrow[a, Par[(Par[b], Par [a -> Par[b]])]]
-- Transformer[b, c] = PArrow[b, Par[(Par[c], Par [b -> Par[c]])]]
-- Transformer[a, c] = PArrow[a, Par[(Par[c], Par [a -> Par[c]])]]
fun composeT[a, b, c](t1: Transformer[a, b], t2: Transformer[b, c]): Transformer[a, c]
  val transformer = fun (x: a)
                      val pTuple = join(runArrow(x, t1)) -- Par[(Par[b], Par [a -> Par[b]])]
                      val clos = fun (tuple: (Par[b], PArrow[a, Par[b]]))
                                   val pb = tuple.0
                                   val inter = join(runParArrow(pb, t2)) -- Par[(Par[c], Par [b -> Par[c]])]
                                   inter >> (fun (tInterm: (Par[c], Par[b -> Par[c]]))
                                              (tInterm.0, A.composePar(tuple.1, tInterm.1))
                                             end)
                                 end
                      bind(clos, pTuple) -- (a -> Par[b]) ->  Par[a] -> Par[b]
                    end
  liftv(transformer)
end

fun runTrans[a, b](item: a, t: Transformer[a, b]): Par[(Par[b], Transformer[a, b])]
  val pp = join(runArrow(item, t))  -- Par[(Par[b], Par[a -> Par[b]])]
  pp >> (fun (p: (Par[b], Par[a -> Par[b]]))
          (p.0, arrT(p.1))
         end)
end

fun runTransT[a, b](item: a, t: Transformer[a, b]): Par[b]
  val pp = join(runArrow(item, t))
  bind(fun (p: (Par[b], Par[a -> Par[b]])) => p.0, pp)
end

fun runParTrans[a, b](p: Par[a], t: Transformer[a, b]): Par[b]
  bind(fun (x: a) => runTransT(x, t), p)
end

fun fixpoint[a](t: Transformer[a, a], p: Par[a], fn: a -> bool): Par[a]
  while true do
    print(".")
    val result = runParTrans(p, t)
    -- TODO: better if this was not a synchronisation point
    val b = get(all(result, fn))
    if b then
      return result
    end
  end
  return empty[a]()
end

fun inc(x: int): Par[int]
  liftv(x + 1)
end

fun double(x: int): Par[int]
  liftv(x * x)
end

fun convertToTrue(x: bool): Par[bool]
  if not x then
    liftv(true)
  else
    liftv(x)
  end
end

fun flipBool(x: bool): Par[bool]
  liftv(not x)
end

-- TODO: add the switch combinator (some paper, for runtime switch of streams)
-- TODO: add the kill combinator which kills streams running ParTs


class Main
  def main(): unit
    -- val arrowInc = A.arr(inc)
    -- val arrowDouble = A.arr(double)
    -- val transformerInc = arrT(arrowInc)
    -- val transformerDouble = arrT(arrowDouble)
    -- val transformer = composeT(transformerInc, transformerDouble)
    -- val p = runTrans(3, transformer)
    -- p >> (fun (t: (Par[int], Transformer[int, int]))
    --         (t.0) >> fun (x: int) => runTrans(x, t.1)
    --       end)

    println("Example.enc")
    val pp = liftv(false) ||| liftv(true)
    val convertB = A.arr(convertToTrue)
    val transformerB = arrT(convertB)
    fixpoint(transformerB, pp, fun (b: bool) => b)

    val flip = A.arr(flipBool)
    val transformerFlip = arrT(flip)
    fixpoint(transformerFlip, pp, fun (b: bool) => b)
  end
end

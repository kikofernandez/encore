module ParTTransformer (
    arrT,
    first,)

import ParT.ParT
import ParT.Arrow as A

typedef Transformer[a, b] = PArrow[a, (Par[b], Par [a -> Par[b]])]

fun arrT[a, b](fn: PArrow[a, Par[b]]): Transformer[a, b]
  val transformer = fun (x: a) => join(runArrow(x, fn))
  A.arr(fun (y: a) => (transformer(y), A.arr(transformer)))
end

fun first[a, b, c](fn: PArrow[a, Par[b]]): Transformer[(a, c), (b, c)]
  val transformer = fun (t: (a, c)) => join(runArrow(t.0, fn)) >> fun (x: b) => (x, t.1)
  A.arr(fun (t: (a, c)) => (transformer(t), A.arr(transformer)))
end


-- Transformer[a, b] = PArrow[a, (Par[b], Par [a -> Par[b]])]
-- Transformer[b, c] = PArrow[b, (Par[c], Par [b -> Par[c]])]
fun compose[a, b, c](t1: Transformer[a, b], t2: Transformer[b, c]): Par[a -> Par[(Par[c], Par [b -> Par[c]])]]  --Par[a -> (Par[c], Par[b -> Par[c]])]
  val xxxxx = fun (tuple: (Par[b], Par [a -> Par[b]]))
                val pb = tuple.0
                bind(fun (x: b) => runArrow(x, t2), pb) -- Par[(Par[c], Par [a -> Par[c]])]
              end
  val transformer = fun (x: a)
                      val pTuple = runArrow(x, t1) -- Par[(Par[b], Par [a -> Par[b]])]
                      bind(xxxxx, pTuple)
                      -- runParArrow(pb, fun (y: b) => runArrow(y, t2))
                      -- join(p >> (fun (tuple: (Par[b], PArrow[a, Par[b]]))
                      --               val pb = tuple.0
                      --               runParArrow(pb, t2) -- Par[(Par[c], Par[b -> Par[c]])]
                      --            end))

                    end
  liftv(transformer)
end

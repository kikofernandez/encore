module ParTTransformer (
    arrT,
    first,)

import ParT.ParT
import ParT.Arrow as A

typedef Transformer[a, b] = PArrow[a, (Par[b], Par [a -> Par[b]])]

fun arrT[a, b](fn: PArrow[a, Par[b]]): Transformer[a, b]
  val transformer = fun (x: a) => join(runArrow(x, fn))
  A.arr(fun (y: a) => (transformer(y), A.arr(transformer)))
end

fun first[a, b, c](fn: PArrow[a, Par[b]]): Transformer[(a, c), (b, c)]
  val transformer = fun (t: (a, c)) => join(runArrow(t.0, fn)) >> fun (x: b) => (x, t.1)
  A.arr(fun (t: (a, c)) => (transformer(t), A.arr(transformer)))
end


-- Transformer[a, b] = PArrow[a, (Par[b], Par [a -> Par[b]])]
-- Transformer[b, c] = PArrow[b, (Par[c], Par [b -> Par[c]])]
fun compose[a, b, c](t1: Transformer[a, b], t2: Transformer[b, c]): PArrow[a, Par[(Par[c], Par [b -> Par[c]])]]
  val transformer = fun (x: a)
                      val pTuple = runArrow(x, t1) -- Par[(Par[b], Par [a -> Par[b]])]
                      bind(fun (tuple: (Par[b], Par [a -> Par[b]]))
                             val pb = tuple.0
                             bind(fun (x: b) => runArrow(x, t2), pb) -- Par[(Par[c], Par [b -> Par[c]])]
                           end, pTuple)
                    end
  liftv(transformer)
end


fun cccc[a, b, c](p1: PArrow[a, Par[b]], p2: PArrow[b, Par[c]]): unit
  -- TODO: Solve this function
  p2 >> (fun (fn: b -> Par[c])
           val clos = fun (pb: Par[b] -> Par[c]) => bind(fn, pb)
           A.compose(p1, clos) -- Par[a -> Par[b]] -> Par[b -> Par[c]]
         end)
end

module ParTTransformer (
    arrT,)

import ParT.ParT
import ParT.Arrow as A

typedef Transformer[a, b] = PArrow[a, Par[(Par[b], Par [a -> Par[b]])]]

fun arrT[a, b](fn: PArrow[a, Par[b]]): Transformer[a, b]
  val transformer = fun (x: a) => join(runArrow(x, fn))
  -- issue: `A.arr` is synonym for `liftv` but it does not typecheck
  A.arr(fun (y: a) => liftv((transformer(y), A.arr(transformer))))
end

fun first[a, b, c](fn: PArrow[a, Par[b]]): Transformer[(a, c), (b, c)]
  val transformer = fun (t: (a, c)) => join(runArrow(t.0, fn)) >> fun (x: b) => (x, t.1)
  A.arr(fun (t: (a, c)) => liftv((transformer(t), A.arr(transformer))))
end

-- a b c -> (b, a b c)
-- Transformer[a, b] = PArrow[a, Par[(Par[b], Par [a -> Par[b]])]]
-- Transformer[b, c] = PArrow[b, Par[(Par[c], Par [b -> Par[c]])]]
-- Transformer[a, c] = PArrow[a, Par[(Par[c], Par [a -> Par[c]])]]
fun compose[a, b, c](t1: Transformer[a, b], t2: Transformer[b, c]): PArrow[a, Par[(Par[c], Par [b -> Par[c]])]]
  val transformer = fun (x: a)
                      val pTuple = join(runArrow(x, t1)) -- Par[(Par[b], Par [a -> Par[b]])]
                      val clos = fun (tuple: (Par[b], PArrow[a, Par[b]]))
                                   val pb = tuple.0
                                   join(runParArrow(pb, t2))
                                 end
                      bind(clos, pTuple) -- (a -> Par[b]) ->  Par[a] -> Par[b]
                    end
  liftv(transformer)
end
